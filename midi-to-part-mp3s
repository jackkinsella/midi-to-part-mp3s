#!/usr/bin/env python3
import mido
import sys
import os

output_directory = "./output/"

def track_names(midi_data):
  return list(map(lambda track: track.name, midi_dat.tracks))

def isolate_tracks(midi_data, track_numbers, output_filename):
  new_file = mido.MidiFile()

  for track_number in track_numbers:
    new_file.tracks.append(midi_data.tracks[track_number])

  new_file_path = "{}/{}.midi".format(output_directory, output_filename)
  new_file.save(new_file_path)

  return new_file_path

def convert_midi_to_mp3(midifile_path):
  file_name_without_extension = os.path.splitext(midifile_path)[0]
  # TODO: Hide output unless debug option on... probably need subprocess.run
  os.system("timidity {} -Ow -o - | lame - {}.mp3".format(
    midifile_path, file_name_without_extension)
  )

def change_instrument(midi_data, program_number):
  for track in midi_data.tracks:
    for message in track:
      if message.type == 'program_change':
        message.program = program_number

def separate_tracks_into_mp3s(midi_data, description):
  for track_name, track_numbers in description.items():
    convert_midi_to_mp3(isolate_tracks(midi_data, track_numbers, track_name))

def cleanup():
  remove_temporary_midifiles()

def remove_temporary_midifiles():
    for midi_file in os.listdir(output_directory):
        if midi_file.endswith('.midi'):
             os.unlink(os.path.join(output_directory, midi_file))

midifile_path = sys.argv[1]

# TODO: Document this and make optional
description = {
  "soprano": [0,1],
  "alt": [0,2],
  "tenor": [0,3],
  "bass": [0,4]
}

midi_data = mido.MidiFile(midifile_path)

change_instrument(midi_data, 0)
separate_tracks_into_mp3s(midi_data, description)
remove_temporary_midifiles()
