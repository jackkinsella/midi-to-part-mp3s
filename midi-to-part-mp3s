#!/usr/bin/env python3
import argparse
import os

import sox
import mido

output_directory = "./output"
sung_parts = ['soprano', 'alt', 'bass', 'tenor']

parser = argparse.ArgumentParser()
parser.add_argument("-no-csts", dest="no_common_tracks", help='file contains no common \
tracks', default=False, action='store_true')
parser.add_argument("-csts", "--common-solo-tracks", help='midi tracks that must appear \
        in all solo mp3s e.g. because they contain time signature changes',
        nargs='+', type=int, default=[0])
parser.add_argument("-s", "--soprano", type=int, default=1)
parser.add_argument("-a", "--alt", type=int, default=2)
parser.add_argument("-t", "--tenor", type=int, default=3)
parser.add_argument("-b", "--bass", type=int, default=4)
parser.add_argument("-iv", "--instrumental-volume", help="configure instrumental volume", type=float, default=2.0)
parser.add_argument("-i", "--instrumental-accompaniment", help='midi tracks that \
        appear in all accompaniment mp3s e.g. piano or orchestra', nargs='+',
        type=int, default=[])
parser.add_argument("-sf", "--soundfont_path", help='the full path to your soundfont', default="./soundfonts/timbres-of-heaven.sf2")
parser.add_argument("midifile_path")
args = parser.parse_args()

class Part:
    def __init__(self, name='', midi='', midi_filepath=''):
        self.name = name
        self.midi = midi
        self.midi_filepath = midi_filepath
        self.mp3 = convert_midi_to_mp3(midi_filepath)

    def mp3_filepath(self):
        return self.midi_filepath.replace(".midi", ".mp3")

def track_names(midi_data):
  return list(map(lambda track: track.name, midi_dat.tracks))

def instrument_number_for_part(part):
    # instrument choices based off advice given here: http://www3.cpdl.org/wiki/index.php/User:Robert_Urmann
    mapping = {
            "soprano": 76, # pan flute
            "alt": 75, # recorder
            "tenor": 49, # string ensemble 1
            "bass": 50 # string ensemble 2
            }
    return mapping[part]

def rescale_velocities(midi_data):
    # full range is 0-127
  min_allowed = 55
  max_allowed = 70

  seen_any_note_ons = False
  for track in midi_data.tracks:
      for message in track:
          if message.type == 'note_on':
              if not seen_any_note_ons:
                  max_observed = message.velocity
                  min_observed = message.velocity
                  seen_any_note_ons = True
              else:
                  max_observed = max(message.velocity, max_observed)
                  min_observed = min(message.velocity, min_observed)

  # TODO: Merge these two iterators and the other message iterator elsewhere
  for track in midi_data.tracks:
      for message in track:
          if message.type == 'note_on':
              x = message.velocity
              rescaled_velocity = int((max_allowed - min_allowed) * ((x -
                  min_observed)/(max_observed - min_observed)) + min_allowed)
              message.velocity = rescaled_velocity

def show_midi_analysis():
  midifile_path = args.midifile_path
  midi_data = mido.MidiFile(midifile_path)
  track_count = len(midi_data.tracks)
  print(f"The file has {track_count} tracks")


def generate_solo_parts(midi_data, track_numbers, part_name):
  midi = mido.MidiFile()
  midi.ticks_per_beat = midi_data.ticks_per_beat

  for track_number in track_numbers:
    midi.tracks.append(midi_data.tracks[track_number])

  if part_name in sung_parts:
      change_instrument(midi, instrument_number_for_part(part_name))
  new_file_path = "{}/{}.midi".format(output_directory, part_name)
  midi.save(new_file_path)

  part = Part(name=part_name, midi=midi, midi_filepath=new_file_path)

  return part

def convert_midi_to_mp3(midifile_path):
  output_base_filename = os.path.splitext(midifile_path)[0]
  # TODO: Hide output unless debug option on... probably need subprocess.run
  os.system("fluidsynth -r 44100 -R 1 -E little -T raw -F - -O s16 {} {} | lame --signed -s 44100 -r - {}.mp3".format(
    args.soundfont_path, midifile_path, output_base_filename
  ))

def change_instrument(midi_data, program_number):
  for track in midi_data.tracks:
    for message in track:
      if message.type == 'program_change':
        message.program = program_number

# TODO: args is being passed too deep into the call-stack
def generate_accompaniment(own_part, solo_parts, args):
  combiner = sox.Combiner()

  accompaniment_volume_ratio = 0.33
  instrumental_volume_ratio = accompaniment_volume_ratio * args.instrumental_volume
  input_volumes = []
  input_files = []
  for part in solo_parts:
      is_own_part = part.name == own_part.name
      is_instrumental = part.name == 'accompaniment'

      input_files.append(part.mp3_filepath())

      if is_own_part:
          input_volumes.append(1)
      elif is_instrumental:
          input_volumes.append(instrumental_volume_ratio)
      else:
          input_volumes.append(accompaniment_volume_ratio)

  output_file_path = "{}/{} mit Begleitung.mp3".format(output_directory, own_part.name)
  combiner.build(input_files, output_file_path, 'mix-power', input_volumes)

def generate_full_mp3(solo_parts):
  combiner = sox.Combiner()

  # docs https://pysox.readthedocs.io/en/latest/api.html
  input_files = [part.mp3_filepath() for part in solo_parts]
  output_file_path = "{}/alle.mp3".format(output_directory)
  combiner.build(input_files, output_file_path, 'mix-power')

def separate_tracks_into_mp3s():
  midifile_path = args.midifile_path
  midi_data = mido.MidiFile(midifile_path)
  solo_parts = []

  rescale_velocities(midi_data)

  for part_name, track_numbers in solo_track_bundles(args).items():
      solo_part = generate_solo_parts(midi_data, track_numbers, part_name)
      solo_parts.append(solo_part)

  for part in solo_parts:
      generate_accompaniment(part, solo_parts, args)

  generate_full_mp3(solo_parts)

def common_solo_tracks():
    if args.no_common_tracks:
        return []
    else:
        return args.common_solo_tracks

def solo_track_bundles(args):
  out = {}
  for part_name in sung_parts:
      track_number = vars(args)[part_name]
      if args.no_common_tracks:
          track_number = track_number -1

      out[part_name] = [track_number] + common_solo_tracks()

  if args.instrumental_accompaniment:
      out['accompaniment'] = args.instrumental_accompaniment + common_solo_tracks()

  return out

def cleanup():
  remove_temporary_midifiles()

def remove_temporary_midifiles():
    for midi_file in os.listdir(output_directory):
        if midi_file.endswith('.midi'):
             os.unlink(os.path.join(output_directory, midi_file))

show_midi_analysis()
separate_tracks_into_mp3s()
cleanup()
